Беззнаковая арифметика в Java
=============================

*За основу этой статьи взята одноимённая статья с Хабра.*

Повышение типа
--------------

Рассмотрим следующий фрагмент кода:

```
byte a = -1; // 255 unsigned
int result = (int) a;
System.out.println(result); // -1
```

Это исправный код, и на экране будет выведено ожидаемое значение -1. Мы-то помним, что в Java все примитивные типы со знаком. Но что мы имеем на уровне битов?

```
11111111 -> 11111111 11111111 11111111 11111111
```

Фактически тоже -1, но уже типа int. Перепишем в шестнадцатеричном виде, чтобы было нагляднее:

```
0xFF -> 0xFFFFFFFF
```

Однако, мы нас интересуют числа без знака. А без знака:

11111111 это 255, а 11111111 11111111 11111111 11111111 это 4294967295 – значение испорчено, так как 255 != 4294967295

Чтобы такого не случалось, повышение типа следует выполнять так:

```
int result = a & 0xFF; // 255
```

То же самое в шестнадцатеричном виде, чтобы было нагляднее:

```
0xFF -> 0x000000FF
```

Сравнение без учёта знака
-------------------------

Функция, следующая:
```
int compareUnsigned(byte a, byte b) {
    return Byte.compare( a - 0x80, b - 0x80 );
}
```

Для short, int и long, соответственно, константы будут `0x8000`, `0x80000000` и `0x8000000000000000L`.
Обязательно посмотрите контракт метода compare. Если в случае Integer результат будет строго: -1, 0 либо 1, то в случае Byte производится вычитание, и диапазон возможных значений больше. Так что не ожидайте 1 или -1, проверяйте, чтобы результат сравнения был больше либо меньше нуля.

В случае с байтами придётся вручную приводить типы:

```
int compareUnsigned(byte a, byte b) {
    return Byte.compare( (byte) (a - 0x80), (byte) (b - 0x80 ));
}
```

Разберём подробнее, что происходит. 0x80 это 1 с последующими нулями. Сравним беззнаковые 127 и 129:

```
01111111 (-1, без знака 127) - 10000000 = 11111111 (-127)
00000001 (1, без знака 129) - 10000000 = 10000001 (127)
-127 < 127
```

В Java 8 уже реализованы эти методы сравнения. Например, для Integer:

```
public static int compareUnsigned(int x, int y) {
    return compare(x + MIN_VALUE, y + MIN_VALUE);
}

public static int compare(int x, int y) {
    return (x < y) ? -1 : ((x == y) ? 0 : 1);
}
```

Сложение, вычитание и умножение
-------------------------------

Эти операции выполняются корректно в любом случае, то есть, никаких преобразований делать не нужно. Правда, есть одно НО.
Необходимо тщательно следить за тем, чтобы **операции в выражениях выполнялись с числами одного типа** (см. выше про повышение типа), так как любые неявные повышения типа выполняются с расширением знака, и такие ошибки очень тяжело отлавливать.
Создавая отрицательные константы типа long обязательно ставьте в конце L, иначе выполнится неявное приведение.


Деление
-------

Разделим два числа типа int. Деление -256 на 256 даст нам -1. Это опять-таки абсолютно верный результат, но если мы пойдём копаться в битах, то обнаружим, что результат этого выражения равен `0xffffffff` (-1). А в контексте беззнаковых вычислений мы хотим, чтобы `0xffffff00 / 0x100` давало `0x00ffffff`. Для byte, short и int решением будет переход к числам большей разрядности:

```
int a = 0xffffff00;
int b = 0x100;
int c = (int) ((a & 0xffffffffL) / b); // convert a to long before division
```

Но что делать с long? В классе Long есть метод divideUnsigned, но посмотрите, что он делает:

```
public static long divideUnsigned(long dividend, long divisor) {
    if (divisor < 0L) { // signed comparison
        // Answer must be 0 or 1 depending on relative magnitude
        // of dividend and divisor.
        return (compareUnsigned(dividend, divisor)) < 0 ? 0L :1L;
    }

    if (dividend > 0) //  Both inputs non-negative
        return dividend/divisor;
    else {
        /*
         * For simple code, leveraging BigInteger.  Longer and faster
         * code written directly in terms of operations on longs is
         * possible; see "Hacker's Delight" for divide and remainder
         * algorithms.
         */
        return toUnsignedBigInteger(dividend).
            divide(toUnsignedBigInteger(divisor)).longValue();
    }
}
```

Если делимое меньше делителя, то вычисления производятся с привлечением класса BigInteger, а это лишняя нагрузка на память и процессор.

В Google Guava в классе `UnsignedLongs.java`: имеется метод `divide`, и он работает быстрее благодаря тому, что не создаётся никаких дополнительных классов. Пример:

```
long quotient = ((dividend >>> 1) / divisor) << 1;
long rem = dividend - quotient * divisor;
return quotient + (compare(rem, divisor) >= 0 ? 1 : 0);
```

Метод compare идентичен тому, что мы разбирали ранее.

Вот ещё более компактный вариант деления:

```
public static long ulongDiv(final long a, final long b) {
return b!=1L? (a>>>1)/(b>>>1): a/b;
}
```

Здесь делимое и делитель переводятся в диапазон положительных чисел.

В классе Integer реализован и метод для деления по модулю: `Integer.remainderUnsigned()`

Другие полезные методы

```
Integer.parseUnsignedInt()
Integer.toUnsignedLong()
Integer.toUnsignedString()
```

Они прячут всю арифметику, которую мы раньше рассматривали. Фактически переменная так же будет int, однако, класс Integer трактует её значение как unsigned int.

А эти методы могут пригодиться при форматировании бинарного представления значения:

```
Integer.numberOfLeadingZeros()
Integer.numberOfTrailingZeros()
Integer.highestOneBit()
Integer.lowestOneBit()
```

Для экономии времени мы не рассматривали здесь другие классы-обёртки: Byte, Short и Long. Принцип их работы аналогичен Integer.


Итого
-----

*	Операции сложения, вычитания, умножения, сдвига влево, логические операции, сравнение и приведение к малым числовым типам прекрасно выполняются с любыми числами: со знаком и без него.
*	Сдвиг вправо: >> если знак есть, >>> если знака нет.
*	Приведение чисел со знаком к большему типу происходит без проблем.
*	Для приведения чисел без знака к большему типу нужно применять маску, например, для short -> long: s & 0xffffL.
*	Простой способ сравнения без головной боли – привести значения к большему типу.
