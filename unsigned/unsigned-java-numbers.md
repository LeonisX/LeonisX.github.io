Беззнаковые целые числа в Java
==============================

_Беззнаковые целые числа в Java используются не часто. В обычной математике, если не хватает разрядности используемого типа, то просто выбирается следующий: byte -> short -> int -> long -> BigInteger. Как правило, даже верхнего значения типа int 2147483647 (2 миллиарда) хватает для всех регулярных вычислений Энтерпрайз систем, и вся математика в Java сводится к тому, чтобы работать с типом int, а byte и short использовать там, где без них никак не обойтись._

_Ну, а если хочется подстраховаться, то есть тип long и его невероятные 9,223,372,036,854,775,808 чисел (9 квинтиллионов!!!). В обычной жизни можно встретить абстрактные миллиарды и триллионы, и то, только в контексте обсуждения миллиардеров или государственного долга США._

Джеймс Гослинг в интервью объяснил, что язык Java разрабатывался максимально простым для того, чтобы программист мог запомнить его. Все частные случаи, отягощающие, например, язык Си, попросту не попали в спецификацию. Джеймс, и его команда, на момент разработки Java были профессиональными программистами и хорошо понимали, что делают. Современный программист может даже не понимать, что происходит на уровне битов, и для Enterprise разработки это не такой уж и редкий случай. Представьте, сколько посыплется багов, когда в одном выражении будут использоваться типы со знаком и без него! А для всех частных случаев написаны библиотеки.

_За более чем 10 лет программирования на Java мне понадобилось эпизодически работать с беззнаковыми целыми числами всего несколько раз, и необходимость всерьёз задуматься над этим возникла только сейчас._

На самом деле, сфера применения целочисленных чисел без знака действительно очень узкая. Вот несколько примеров, где это может пригодиться:

*	Взаимодействие с внешними API, работающими с целочисленными значениями без знака
*	Бинарные потоки, где важна их интерпретация байтов как чисел без знака
*	Двоичная арифметика (в том числе, и быстрое портирование кода с других языков)
*	Специализированные базы данных
*	Замена значения определённой разрядности в бинарном файле
*	HEX-редакторы

Для того, чтобы выбрать вариант обработки беззнаковых чисел, следует сначала определиться с проектом и требованиями к нему.

_Одна из сильнейших сторон Java – это строгая типизация. Разработчики языка очень фанатично подходят к этому вопросу, и подчас, программистам даже приходится бороться с навязываемыми ограничениями, скрывая предупреждения, вручную приводя типы, или придумывая типизацию генериков. Но все эти страдания не идут ни в какое сравнение с теми страданиями, которые начинаются при поиске багов, связанных с нестрогой типизацией в других языках._

Java контролирует тип каждого значения на протяжении всего его жизненного цикла: создании, передаче, обработке, использовании и сохранении.*

_* Немного громкое заявление. Есть ещё стирание типов (types erasure), ради которых были введены генерики, но и они со своей задачей не справляются на 100%._

Тем не менее, при работе с любым типом в Java не теряется уверенность в том, что это тип именно тот, каким был объявлен.

Поскольку в Java не предусмотрено специальных типов для беззнаковых чисел, то контролировать типизацию приходится программистам.

Известны две основные стратегии хранения беззнаковых типов:

1.	Контейнер: переменная большей разрядности
2.	Контейнер той же разрядности

Если используется контейнер той же разрядности, то необходимо реализовать кастомные методы обработки беззнакового значения. Если контейнер большей разрядности, то значение не выходит за пределы допустимого, и всё множество операций из Java доступно из коробки.

В идеальном случае необходимо следует реализовать полноценный класс-обёртку, наподобие Integer, чтобы контролировать тип на протяжении всего его жизненного цикла: 

*	Создание
*	Передача
*	Обработка
*	Использование
*	Сохранение

Совершенно очевидно, что контроль на каждом из этапов это дополнительные нагрузки на память и процессор, поэтому, обычно ищутся компромиссы. Например, иногда бывает достаточно контролировать чтение и запись значения, и для этого классы-обёртки не нужны, хватит одних вспомогательных методов. Либо, можно осуществлять контроль лишь на этапе обработки, реализовав вспомогательный класс со статическими методами. Всё зависит от источника данных и поставленных целей.
 
Вот три основных варианта и доступных решения:

*	Маленький проект, сопровождается одним человеком
*	Большой проект, сопровождается командой
  *	Беззнаковые числа нужны редко, соответственно, нет особых требований и ограничений
  *	Беззнаковые числа нужны часто, есть особые требования и ограничения

Самый банальный вариант решения - понимать в каком месте кода может появиться беззнаковое число и реализовать его обработку вручную.

Для больших проектов лучше реализовать максимальный контроль типов, то есть, использовать классы-обёртки.

Для достижения производительности и/или экономии памяти обычно контролируется самая уязвимая часть жизненного цикла беззнакового типа.
