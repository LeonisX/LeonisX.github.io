Целочисленное переполнение
==========================

Это ситуация, при которой результат вычисления не помещается в тип исходных операндов. Не будем конкретизировать, что переполнение может быть как верхней, так и нижней границы, важен сам факт. Пример четырёхбитовых значений, чтобы было понятнее:

```
1111 + 1 = 1 0000
```

Если нас попросят вернуть число с разрядностью 4 бита, то старший бит потеряется, и результат вычисления будет неверным.

Java защищает нас от таких ситуаций, автоматически повышая тип результата.

Вот цитата из спецификации языка:

*	Если один из операндов имеет тип double, то другой преобразуется в double.
*	Иначе, если один из операндов имеет тип float, то другой преобразуется в float.
*	Иначе, если один из операндов имеет тип long, то другой преобразуется в long.
*	Иначе оба операнда приводятся к типу int.

byte, short
-----------

Результат сложения двух байтов или двух значений типа short ВСЕГДА имеет тип int. Java вообще очень любит тип int и старается приводить результат всех вычислений к этому типу, если это возможно. Такой, казалось бы, безобидный фрагмент кода даже не скомпилируется:

```
byte a = 1;
byte b = 2;
byte result = a + b;

error: incompatible types: possible lossy conversion from int to byte
```

Если же эти значения заинлайнить, то ошибки не будет:

```
byte result2 = (byte) 1 + (byte) 2;
```

Кто знает в чём подвох – напишите пожалуйста на почту.

Операции с типами byte и short никогда не завершатся переполнением, поскольку результат имеет 32 бита. Тип операндов повышается до int, и потом выполняется операция над ними.

**Результат ЛЮБЫХ операций над типами byte, short, boolean и char это ВСЕГДА int.**

И это при том, что, допустим, логические операции, или поразрядный сдвиг вправо никогда не выйдут за пределы исходного типа. Эта унификация была сделана из экономии. Дело в том, что в JVM размер опкода всего 1 байт, и следовательно, количество опкодов виртуальной машины строго ограничено, чтобы растрачиваться на инструкции для мало используемых типов.

Если мы хотим на выходе получить значение типа byte, то надо выполнять принудительное приведение типов, и тут уже не получится всё свалить на плохо продуманную архитектуру языка. Выполняя принудительное приведение типа следует быть уверенным, что результат будет оставаться в области допустимых значений.

Вот пример того, как можно отстрелить себе ногу:

```
byte b1 = 127;
byte b2 = 1;
int result = b1 + b2;
short shortResult = (short) (b1 + b2);
byte byteResult = (byte) (b1 + b2);
System.out.println("Integer result: " + result);
System.out.println("Short result: " + shortResult);
System.out.println("Byte result (wrong): " + byteResult);
```

Результат выполнения программы:

```
Integer result: 128
Short result: 128
Byte result (wrong): -128
```

То есть, Java позволяет принудительно приводить тип, но в этом случае программист берёт на себя всю ответственность за контроль над переполнением.

Есть место, где, по понятным причинам, повышения типа не происходит. Например, такая ошибка приводит к созданию бесконечного цикла.

```
for (byte i = 0; i < 200; i++) {
    System.out.println(i);
}
```

В этой ситуации можно только дать совет сразу выбирать требуемый тип переменной. Как правило, int хватает для любых случаев, поскольку, даже массивы в Java не выходят за пределы int. Кстати, современные IDE, например, IntelliJ IDEA подсвечивают такие места в коде.

int
---

С типами int и long дела обстоят не так хорошо. Java не контролирует переполнение. Результат вычисления имеет ту же разрядность, какая есть у самого большого из операндов, и технически результат вычисление верный, а ошибка возникает из-за неверной трактовки результата.

Пример:

```
System.out.println(Integer.MAX_VALUE + 1);
```

Результат: -2147483648

Давайте вручную выполним эту операцию.

```
01111111111111111111111111111111 + 1 = 10000000000000000000000000000000
```

Самый старший бит равен единице, соответственно, мы и получили отрицательное число. При этом с битами всё в порядке, ничего не потерялось, и ничего не прибавилось, если считать знаковый бит как часть значения, то можно извлечь и беззнаковое значение, а как это сделать мы посмотрим ниже.

В Java 8 вышло запоздалое решение, связанное с проверкой переполнений. Пример:

```
System.out.println(Math.addExact(Integer.MAX_VALUE, 1));
```

Результат:

```
Exception in thread "main" java.lang.ArithmeticException: integer overflow
	at java.base/java.lang.Math.addExact(Math.java:825)
	at …
```

То есть, чтобы впереди не маячила перспектива поиска ошибок, связанных с переполнением, выставляется проверка, и если ошибка всё-таки возникает, то надо подумать о том, чтобы перейти на тип long.

*Можно так же вставлять оператор assert с требуемым условием.*


long
----

О переполнении типа long тоже можно узнать аналогичным образом с помощью методов класса Math: `addExact, decrementExact, incrementExact, multiplyExact, negateExact, substractExact`, однако, решение уже не будет таким простым. Пока мы не перешли к нему, давайте познакомимся ещё с методом `Math.toIntExact` – это проверка приведения long к int.

Если число не умещается в тип long, то в Java есть следующие альтернативы:

*	Double
*	BigInteger
*	String
*	byte[]

Среди них только тяжеловесный BigInteger позволяет из коробки работать со значением, как с числом. Строки и массив байтов подходят для хранения. Double использовать не рекомендуется, потому что у больших значений теряются младшие биты.

Кстати, BigInteger это обёртка над int[].

Итого:

*	Если ваши значения не умещаются в int, то берите long. Если и long не справляется, то берите BigInteger.
*	Примитивные типы byte и short есть смысл использовать только в массивах, если необходимо экономить место.
*	Если нужно строго 64/32/16/8 бита, то используйте long/int/short/byte и не переживайте о знаке, если не выполняете:
    *	Деление
    *	Сравнение
    *	Смещение вправо
    *	Приведение типов

<p align="center">
   <a href="numbers-operations.md"><<< Арифметические и логические операции</a> | <a href="toc.md">Оглавление</a> | <a href="unsigned-arithmetics-java.md">Беззнаковая арифметика в Java >>></a>
</p>
