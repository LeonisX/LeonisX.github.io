Целочисленное переполнение
==========================

Это ситуация, при которой результат вычисления не помещается в тип исходных операндов. Переполнение может быть как верхней, так и нижней границы. Пример четырёхбитовых значений, чтобы было понятнее:

```
1111 + 1 = 1 0000
```

Если нас попросят вернуть число с разрядностью 4 бита, то старший бит потеряется, и результат вычисления будет неверным.

Java лишь частично защищает нас от таких ситуаций.

При вычислениях происходит автоматическое повышение типа результата.

Вот цитата из спецификации языка:

* Если один из операндов имеет тип double, то другой преобразуется в double.
* Иначе, если один из операндов имеет тип float, то другой преобразуется в float.
* Иначе, если один из операндов имеет тип long, то другой преобразуется в long.
* Иначе оба операнда приводятся к типу int.

Если мы складываем два числа типа int, и результат не умещается в тип int, мы попросту теряем значение из крайнего левого бита. **О целочисленном переполнении должен заботиться программист**. Типы byte и short на фоне int и long являются "приятным" исключением, но причина, из-за которой ои были так реализованы, не связана с переполнением.


byte, short
-----------

Результат сложения двух байтов или двух значений типа short ВСЕГДА имеет тип int. Java вообще очень любит тип int и старается приводить результат всех вычислений к этому типу, если это возможно. Такой, казалось бы, безобидный фрагмент кода даже не скомпилируется:

```
byte a = 1;
byte b = 2;
byte result = a + b;

error: incompatible types: possible lossy conversion from int to byte
```

Если же эти значения заинлайнить, то ошибки не будет:

```
byte result2 = (byte) 1 + (byte) 2;
```

Кто знает в чём подвох – напишите пожалуйста на почту.

Операции с типами byte и short никогда не завершатся переполнением, поскольку результат имеет 32 бита. Тип операндов повышается до int, и потом выполняется операция над ними.

**Результат ЛЮБЫХ операций над типами byte, short, boolean и char это ВСЕГДА int.**

И это при том, что, допустим, логические операции, или поразрядный сдвиг вправо никогда не выйдут за пределы исходного типа. Эта унификация была сделана из экономии. Дело в том, что в JVM размер опкода всего 1 байт, и следовательно, количество опкодов виртуальной машины строго ограничено, чтобы растрачиваться на инструкции для мало используемых типов.

Если мы хотим на выходе получить значение типа byte, то надо выполнять принудительное приведение типов, и тут уже не получится всё свалить на плохо продуманную архитектуру языка. Выполняя принудительное приведение типа следует быть уверенным, что результат будет оставаться в области допустимых значений.

Вот пример того, как можно отстрелить себе ногу:

```
byte b1 = 127;
byte b2 = 1;
int result = b1 + b2;
short shortResult = (short) (b1 + b2);
byte byteResult = (byte) (b1 + b2);
System.out.println("Integer result: " + result);
System.out.println("Short result: " + shortResult);
System.out.println("Byte result (wrong): " + byteResult);
```

Результат выполнения программы:

```
Integer result: 128
Short result: 128
Byte result (wrong): -128
```

То есть, Java позволяет принудительно приводить тип, но в этом случае программист берёт на себя всю ответственность за контроль над переполнением.

У переменных цикла, по понятным причинам, автоматического повышения типа не происходит. Например, такая ошибка приводит к созданию бесконечного цикла.

```
for (byte i = 0; i < 200; i++) {
    System.out.println(i);
}
```

В этой ситуации можно только дать совет сразу выбирать верный тип переменной. Как правило, int хватает для любых случаев, поскольку, даже массивы в Java не выходят за пределы int. Кстати, современные IDE, например, IntelliJ IDEA подсвечивают такие места в коде до того, как ошибка утечёт в продакшен.

int
---

С типами int и long дела обстоят не так хорошо. Java не контролирует переполнение и не повышает разрядность автоматически. Результат вычисления имеет разрядность самого большого из операндов, и, даже если на уровне битов результат вычисление верный, на экране может отобразиться не то число, которое программист хочет увидеть.

Пример:

```
System.out.println(Integer.MAX_VALUE + 1);
```

Результат: -2147483648

Давайте вручную выполним эту операцию.

```
01111111111111111111111111111111 + 1 = 10000000000000000000000000000000  
```

Самый старший бит равен единице, соответственно, это отрицательное число. При этом с битами всё в порядке, ничего не потерялось, и ничего не прибавилось, и, если трактовать знаковый бит как часть беззнакового значения, то его можно извлечь из переменной, а как это сделать мы посмотрим ниже.

В Java 8 вышло запоздалое решение, связанное с проверкой переполнений. Пример:

```
System.out.println(Math.addExact(Integer.MAX_VALUE, 1));
```

Результат:

```
Exception in thread "main" java.lang.ArithmeticException: integer overflow
	at java.base/java.lang.Math.addExact(Math.java:825)
	at …
```

То есть, чтобы впереди не маячила перспектива поиска ошибок, связанных с переполнением, выставляется проверка, и если ошибка всё-таки возникает, то надо подумать о том, чтобы перейти на тип long.

*Можно так же вставлять оператор assert с требуемым условием.*


long
----

О переполнении типа long тоже можно узнать аналогичным образом с помощью методов класса Math: `addExact, decrementExact, incrementExact, multiplyExact, negateExact, substractExact`, однако, решение уже не будет таким простым. Пока мы не перешли к нему, давайте познакомимся ещё с методом `Math.toIntExact` – это проверка приведения long к int.

Если число не умещается в тип long, то в Java есть следующие альтернативы:

*	Double
*	BigInteger
*	String
*	byte[]

Среди них только тяжеловесный BigInteger позволяет из коробки работать со значением, как с числом. Строки и массив байтов подходят для хранения. Double использовать не рекомендуется, потому что у больших значений теряются младшие биты.

Кстати, BigInteger это обёртка над int[].

Итого:

*	Если ваши значения не умещаются в int, то берите long. Если и long не справляется, то берите BigInteger.
*	Примитивные типы byte и short есть смысл использовать только в массивах, если необходимо экономить место.
*	Если нужно строго 64/32/16/8 бита, то используйте long/int/short/byte и не переживайте о знаке, если не выполняете:
    *	Деление
    *	Сравнение
    *	Смещение вправо
    *	Приведение типов

<div align="center">
	
[<<< Арифметические и логические операции](numbers-operations.md) | [Оглавление](toc.md) | [Беззнаковая арифметика в Java >>>]
</div>
