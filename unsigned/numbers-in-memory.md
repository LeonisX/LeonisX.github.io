Представление чисел в памяти ПК
===============================

Давайте опустимся до уровня процессоров. Что мы знаем о них? Основная характеристика любого процессора — это его разрядность. То есть, сколько бит он может обработать за один раз. Начиналось всё с 4–8 бит, а современные процессоры имеют разрядность 64 бита и выше.

Процессору на самом деле всё равно, что будет находиться в этих битах. Это удел программиста интерпретировать каждую последовательность нулей и единиц. Например, `11011010` может быть и `218` и `-38` и буквой "`Ъ`" в русском языке.

Исторически сложилось, что вся вычислительная техника оперирует не битами, а байтами, то есть, группами по 8 бит. Вся двоичная математика полностью повторяет десятичную, за исключением того, что переход выполняется не после девятки, а после единицы. Например, `1, 2, 3, 4, 5` это `1, 10, 11, 100, 101`. Чем число находится левее, тем его вес выше.

И пока процессоры были 8-ми разрядными, это устраивало всех. Однако, с появлением 16-битных процессоров возникла путаница. Одни процессоры, например Motorola 68000, продолжили использовать привычный порядок чисел, известный как `big-endian`. И этот порядок является стандартным для протоколов TCP/IP.

Разработчики из Intel пошли другим путём. 2 байта, хранящие число 0x00FF в памяти IBM-совместимых машин хранятся как FF00. Порядок от младшего к старшему (`little-endian`), если верить Википедии, очень удобен тем, что при увеличении размера (количества байтов) операнда, значение его первого байта остаётся неизменным.

_Информация о порядке байтов в числах, в большей степени, пригодится только тем, кто ищет или меняет значения в бинарном файле. Числа в коде записываются в привычном для нас виде, и обо всех перестановках байтов можно даже не переживать._

Порядок байтов так же не важен для строк, буквы в памяти хранятся в том порядке, в котором и читаются.

Но, давайте вернёмся к числам. Мы уже знаем как в памяти хранятся положительные числа. А что с отрицательными? Здесь тоже нет единого решения. Известно как минимум три варианта:

* `Обратный код` (ones’ complement), известен ещё со времён механических арифмометров. В нём все биты отрицательного числа инвертированы. Например, положительное число 00000101 (пять) со знаком минус будет записано как 11111010 (-5). Это позволяет вычитать одно число из другого с помощью операции сложения.
* `Прямой код` просто интерпретирует крайний левый бит как знак числа. Например, 10000101 (-5). У него достаточно много недостатков, в частности, два варианта записи числа 0 и усложнённая аппаратная реализация.
* `Дополнительный код` берёт всё лучшее из двух предыдущих. Он немного сложнее в понимании, однако, это неудобство компенсируется несколькими серьёзными преимуществами.

`Дополнение до двух` (two’s complement) – а именно в этом формате хранятся все отрицательные числа Java, настолько эффективен, что вытеснил все остальные архаичные способы записи отрицательных чисел. В частности:

* Операция вычитания не нужна, достаточно операции сложения
* Одинаковое сложение-вычитание для чисел со знаком и без него
* Одинаковый сдвиг влево для чисел со знаком и без него

Это упрощает устройство процессора.

Алгоритм для получения отрицательного числа в дополнительном коде такой:

1.	Инвертировать все биты положительного числа
2.	Прибавить к нему 1

Пример чисел:

```
00000101 (5)
11111011 (-5)
```

Пример вычисления отрицательного числа: 

```
~00000101 = 11111010
11111010 + 1 = 11111011
```

Очевидно, что старший бит является знаковым. Если он равен нулю, то число положительное.

Дополнение до двух имеет и свои недостатки, главным образом, неудобство чтения raw значений людьми, но это та данность, с которой нам придётся сейчас разбираться.

<div align="center">

[<<< Вступление](unsigned-java-numbers.md) | [Оглавление](toc.md) | [Арифметические и логические операции >>>](numbers-operations.md)
</div>
