Решения для работы с Unsigned числами + исследования
====================================================

Самый универсальный способ работы с целочисленными примитивными типами — это использование специализированных классов-обёрток. Под капотом будут находиться обычные типы Java, а обёртка берёт на себя все функции по их обработке и проверке значений.

Универсального решения, конечно, не существует, но на фоне остальных своей зрелостью выделяется Google Guava.

|              | [Google Guava](https://github.com/google/guava/tree/master/guava/src/com/google/common/primitives) | [jOOU](https://github.com/jOOQ/jOOU/tree/main/jOOU/src/main/java/org/joou) | [Apache Axis](https://github.com/robig/axis2-adb/tree/master/src/main/java/org/apache/axis2/databinding/types) | [OPC Foundation](https://github.com/OPCFoundation/UA-Java-Legacy/tree/master/src/main/java/org/opcfoundation/ua/builtintypes) | [JNIWrapper](https://www.teamdev.com/downloads/jniwrapper/javadoc/com/jniwrapper/package-summary.html) | [YSTT/Kaitai](https://github.com/LeonisX/yoda-stories-translation-tool/blob/main/src/main/java/md/leonis/bin/Dump.java) |
|     :---:    |     :---:    |     :---:   |     :---:     |     :---:     |     :---:      |     :---:      |
| Создание     |	***	      | ***         |	*** |	*** |	*** |	*** |
| Передача     |	***	      | ***         |	*** |	*** |	*** |	-   |
| Обработка    |	***	      | *           |	*   |	**  |	-   |	-   |
| Сохранение   |	***       |	***         |	*** |	*** |	*** |	*** |
| Память       |	**	      | *           |	*   |	*   |	*   |	*** |
| Процессор    |	***       | **          |	**  |	**  |	**  |	*** |
| Автономность |	***       |	***         |	**  |	*** |	*** |	*   |

Чем больше звёздочек, тем лучше. Максимально - три звезды, оценки носят относительный характер. 

Проведём несколько небольших экспериментов по сравнению библиотек. Скажем сразу, без глубоких познаний о внутренней работы JVM и соблюдения всех необходимых условий, написать точные бенчмарки на Java нереально. Наши тесты тоже не идеальные, но по результатам их работы можно видеть общую картину.

Заполнение массива ёмкостью 256 миллионов чисел. Участвуют классы byte, Byte, short, Short, а так же реализации от jOOU.

| Характеристика              | byte  | Byte | UByte | short | Short | UShort |
|   :---:                     | :---: |:---: | :---: | :---: | :---: | :---:  |
| Потребление памяти, мб      |  256  | 1024 | 1024  |  509  | ~5050 | ~5100  |
| Время заполнения массива, с |  3.3  | 3.35 | 3.35  |  3.6  | 67.5  |   85   |

Потребление памяти достаточно ожидаемое:

* byte: ровно 256 Мб.
* Byte и UByte: в 4 раза больше - это размер ссылки на объект в кэше.
* short: в 2 раза больше чем byte. Это норма
* Short примерно в 20 раз больше. Очень странно, потому что UShort, оперируя полем типа int потребляет столько же.
* UShort примерно в 20 раз больше. Цена создания класса такая же как и у UnsignedInteger.

Время создания что примитивных типов byte, что 8-ми разрядных объектов почти одинаковая. А в случае Short и UShort что-то пошло не так. Обратите внимание на время заполнения массива. Это просто ужас. Чтобы завершить тесты, нам пришлось уменьшить массив в 5 раз, настолько задержки были большими.

Складывается впечатление, что тип Short не оптимизированный. Кроме медленной работы он ещё и съедает много памяти. Вероятно переменные типа short в качестве поля объекта фактически сохраняются как int.

Заполнение массива ёмкостью 256 миллионов чисел. Участвует класс int, а так же реализации от Google Guava и jOOU.

| Характеристика              | int  | UnsignedInteger | UInteger |
|   :---:                     |:---: |     :---:       |  :---:   | 
| Потребление памяти, мб      | 1026 | 5122            | 7170     | 
| Время заполнения массива, с | 2.97 | 10              | 10.6     |

Потребление памяти достаточно ожидаемое:

* int: в 4 раза больше ёмкости массива. 4 байта это размер типа int.
* UnsignedInteger: в 20 раз больше.
* UInteger: в 28 раз больше.

Создание объекта обходится дорого. А если тип его поля long вместо int, то памяти съедается ещё больше.

Кэширование в jOOU здесь не сильно помогает, потому что по умолчанию кэш покрывает лишь малую часть диапазона значений класса int.

Сейчас рассмотрим операции сложения.

| Характеристика    | int  | UnsignedInteger | UInteger |
|  :---:            |:---: |     :---:       |  :---:   | 
| Время сложения, с | 3    | 3.3             | 4.0      |

Разброс небольшой, Google Guava демонстрирует хорошие результаты.

В следующем тесте посмотрим скорость выполнения деления. Напомним, что для беззнаковых чисел это достаточно трудоёмкая операция. Здесь сравниваются методы деления из Java и Google Guava. Код метода ulongDiv() мы приводили выше.

| Характеристика   | long/long | ulongDiv | Long.divideUnsigned | UnsignedLong.divide | UnsignedLongs.divide |
|  :---:           |   :---:   |   :---:  |  :---:              |   :---:             |   :---:              | 
| Время деления, с |   13.5    | 13.5     |   21                |    8.5              |    8.5               | 

Допустим, результат `Long.divideUnsigned` был ожидаемым, так как в операциях деления участвует медленный класс `BigInteger`. Но что творится с остальными показателями? Нам тяжело это комментировать. Фактически, Google Guava отработала почти в 2 раза быстрее, чем операция простого деления. Как такое возможно? Были написан другой тест, с использованием метода `UnsignedLong.fromLongBits()` и, в зависимости от того, был ли делитель больше делимого, время выполнения составляло от 9.5 до 11.5 секунд, что всё равно быстрее обычной операции деления!

У нас не было времени на тестирование всех методов всех библиотек. Google Guava прекрасно зарекомендовала себя на больших числах, но не имеет в арсенале специализированные классы для значений byte и short. Вероятно, за счёт системы кэширования, jOOU лучше себя проявит для этих типов.

Давайте рассмотрим, что интересного можно найти в реализациях от разных авторов.

Google Guava
------------

Это полноценная библиотека для поддержки беззнаковых типов. Имеет в арсенале классы-обёртки, `UnsignedInteger, UnsignedLong`, и вспомогательные классы для всех примитивных типов.

UnsignedInteger можно создавать из переменных типов `int, long, BigInteger, String`, а так же из другого беззнакового `int`. Под капотом находится переменная типа `int`. Интересно название метода fromIntBits(int bits) - авторы ведь могли назвать этот метод fromUnsignedInt. Методы:

*	plus
*	minus
*	times
*	divideBy
*	mod

UnsignedLong работает по такому же принципу, но под капотом скрывается переменная типа long.

Классы `UnsignedBytes, InsignedInts, UnsignedLongs` функционально очень похожи. Рассмотрим методы класса `UnsignedInts`:

*	checkedCast (long -> int), бросает ошибку
*	saturatedCast (long -> int), преобразует тип так близко, насколько это возможно
*	compare
*	min
*	max
*	join – объединяет массив примитивного типа в строку
*	sort – сортирует массив примитивного типа
*	sortDescending
*	divide
*	remainder
*	parseUnsigned…
*	decode (Hex String)


jOOU
----

Ещё одна полностью специализированная библиотека для работы с беззнаковыми числами. Маленькая, но достаточно проработанная.

Классы-обёртки: `UByte, UInteger, ULong, UShort, UNumber`.
Вспомогательные классы: `UMath, Unsigned`.

Классы-обёртки (кроме UShort) кэшируют определённые диапазоны значений. Например, UByte – все возможные 256 чисел. Размер кэша можно задавать через системные свойства.

В этих классах много перегруженных методов valueOf, так же есть перегруженные методы add и subtract.

Теоретическая производительность достигается за счёт большего потребления памяти:

*	UByte: short
*	UShort: int
*	UInteger: long
*	ULong: BigInteger

Фактическая производительность, вероятно, не будет такой заметной, потому что библиотека Google Guava в целом лучше оптимизирована.

Так же, из-за того, что не требуется выполнять проверки на переполнение, API получился компактнее и чище.

Класс UMath содержит перегруженные методы max и min.

Класс Unsigned содержит фабричные методы для создания беззнаковых типов - методы valueOf().


Apache Axis
-----------

Беззнаковое число для всех типов `UnsignedByte, UnsignedShort, UnsignedInt` хранится в переменной типа Long. `UnsignedLong` написан на основе BigInteger.

Вариантов создания этих объектов очень много, в качестве аргументов конструктора можно использовать и примитивные типы, и BigInteger и даже строки.

Эти классы используются только для передачи данных, в них нет поддержки беззнаковой арифметики. Единственное что они позволяют, это выполнять беззнаковое сравнение.


OPC Foundation UA JAVA Legacy
-----------------------------

На первый взгляд кажется, что потребление памяти будет избыточным:

* UnsignedByte: int
* UnsignedShort: int
* UnsignedInteger: int
* Unsigned long: long

Однако, за счёт кэширования это должно быть не так сильно заметно.

Классы имеют несколько типов конструкторов и методы: `valueOf, max, min, inc, dec, add, subtract`.

Опираясь на предыдущие исследования можно советовать эту библиотеку для случаев, когда ведётся интенсивная работа со значениями типа short. Так же очень вероятно, что библиотека сможет составить хорошую конкуренцию jOOU. 


DIS-Java-VRML
-------------

Просто набор классов-обёрток, не несущих какой-либо дополнительной функциональности. Проект очень старый, не нашлось даже исходников, лишь [JavaDoc](http://faculty.nps.edu/brutzman/vrtp/javadoc/dis-java-vrml/mil/navy/nps/util/package-summary.html).


JNIWrapper 
----------

Это платный продукт, в котором есть поддержка разнообразнейших типов, включая: `UInt, UInt16, UInt32, UInt64, UInt8, UShortInt`.

Складывается впечатление, что эти классы не очень дружелюбны к памяти. По крайней мере, метод getValue для всех этих типов возвращает long. 

Из необычного – методы для записи в DataBuffer.


Yoda Stories Translation Tool / Kaitai Struct
---------------------------------------------

*Здесь описано решение, при котором беззнаковые типы сопровождаются только на этапах чтения и записи.*

Утилита [Yoda Stories Translation Tool](https://github.com/LeonisX/yoda-stories-translation-tool) изначально использовала следующее решение: класс `Dump`, хранящий байтовый массив, и обеспечивающий чтение/запись чисел различной разрядности и порядка байтов, а также сохранение и загрузку массива.

Впоследствии часть кода была заменена более прогрессивным решением.

Язык [Kaitai Struct](https://kaitai.io) описывает структуру различных бинарных форматов: архивов, мультимедиа файлов, файловых систем, баз данных, исполняемых файлов, сетевых протоколов, и даже файлов данных из различных игр.

Для разработки `KSY` файлов есть даже свои IDE. После описания структуры бинарного файла, на её основе можно скомпилировать код для чтения этой структуры, причём, поддерживается порядка 12-ти языков, включая и Java.

Этот код представляет собой иерархию классов, описывающих структуру бинарного файла. Чтение данных производится последовательно. В каждом классе есть метод `_read()`, который забирает свою порцию данных для инициализации полей класса.

Дополнительно следует подключить библиотеку, отвечающую за чтение из файлов или байтовых массивов. `KaitaiStream` имеет две реализации, для последовательного и произвольного доступа к бинарным данным.

В названии всех методов используется информация о типе данных:

*	Со знаком или без: `S / U`
*	Разрядность исходных данных: `1, 2, 4, 8`
*	Порядок байтов: `be, le`

Пример:

```
ByteBuffer bb;

public byte readS1() { // read signed byte
    return bb.get();
}

public int readS4be() { // read signed int with BigEndian byte order
    bb.order(ByteOrder.BIG_ENDIAN);
    return bb.getInt();
}

public long readU4le() { // read unsigned int with LittleEndian order
    bb.order(ByteOrder.LITTLE_ENDIAN);
    return bb.getInt() & 0xffffffffL;
}
```

Числа без знака занимают в памяти в два раза больше места, но зато к ним можно применять любые операции Java без ограничений. А что насчёт long?

```
public long readU8le() { // read “unsigned” long with LittleEndian order 
    return readS8le();
}
```

Переиспользуется метод для чтения long со знаком, соответственно, если понадобится менять это значение, то придётся дополнительно потрудиться.

Так же есть методы для чтения чисел с плавающей запятой, байтовых массивов, битов и строк. Поддерживается сравнение массивов, а также поиск минимума и максимума.

Поскольку работа Yoda Stories Translation Tool подразумевает изменение и сохранение данных, эта функциональность была доработана.

*	KaitaiInputStream
    *	ByteBufferKaitaiInputStream
    *	RandomAccessKaitaiInputStream
*	KaitaiOutputStream
    *	ByteBufferKaitaiOutputStream


`KaitaiOutputStream` это зеркальная реализация `KaitaiInputStream` для записи бинарных данных в файл, байтовый массив или ByteBuffer.

Пример методов:

```
public void writeS4be(int value) {
    bb.order(ByteOrder.BIG_ENDIAN);
    bb.putInt(value);
}

public void writeU4le(int value) {
    bb.order(ByteOrder.LITTLE_ENDIAN);
    bb.putInt(value);
}

public void writeU4le(long value) {
    writeU4le((int) value);
}
```

Выполняется простое приведение типа, и оно не вызывает никаких проблем, если в long хранится значение, не выходящее за пределы int. Проверки на выход за пределы области допустимых значений отсутствуют.

В каждом классе, описывающем бинарный файл в дополнение к методу `_read` реализован полностью зеркальный метод `_write`.



### Хранение данных в виде массива байтов

Здесь будет показан пример хранения данных в виде массива байтов. Этот способ нашёл своё применение в утилите Yoda Stories Translation Tool.

Он привлекателен тем, что занимает ровно столько памяти, сколько занимает бинарный файл.

Класс `Dump` содержит в себе не только массив, но и подмножество методов для доступа к его элементам.

Есть возможность получать данные с различным порядком байтов:

```
public enum ByteOrder {
    BIG_ENDIAN,
    LITTLE_ENDIAN
}
```

Конструкторы позволяют загрузить данные из файлов, или создать буфер необходимой вместимости. Поскольку в большинстве случаев данные читаются последовательно, то реализована поддержка указателя и базового смещения. При каждом чтении данных указатель сдвигается на размер прочитанных данных. Методы для чтения: 

```
getByte
getWord
getLongWord
getChar
getString
getBoolean
getArray
```

К качеству и производительности кода может быть много претензий, но, по крайней мере вычисления наглядно показывают, что происходит:

```
public int getWord() {
  int result;
  switch (byteOrder) {
    case LITTLE_ENDIAN:
    result = Byte.toUnsignedInt(dump[index]);
    index++;
    result += Byte.toUnsignedInt(dump[index]) * 256;
    index++;
    break;
  default:
    result = Byte.toUnsignedInt(dump[index]) * 256;
    index++;
    result += Byte.toUnsignedInt(dump[index]);
    index++;
    break;
  }
  return result;
}
```

Существуют аналогичные методы для изменения значений: `setByte`, …

Другие методы:

*	writeHexDump
*	erase
*	get/setOffset
*	get/setIndex
*	insertEmptyArea
*	deleteArea
*	findAddress
*	findValueAddressByMask
*	findAddressWithMask
*	get/setCharset.

Кодировка необходима, если извлекаются строковые значения. По умолчанию это `Cp2152`.

Пожалуй, это всё, что хотелось рассказать про работу с беззнаковыми типами в Java. Если у вас есть вопросы, или вы заметили какие-то неточности или недочёты, то обязательно напишите мне. Благодарю.

<p align="center">
   <a href="unsigned-arithmetics-java.md"><<< Беззнаковая арифметика в Java</a> | <a href="toc.md">Оглавление</a>
</p>
